\label{index_md_README}%
\Hypertarget{index_md_README}%
 Siga estos pasos para ejecutar el programa de evaluación de alergias\+:


\begin{DoxyEnumerate}
\item Asegúrese de tener Python 3 instalado en su sistema. Puede descargarlo desde \href{https://www.python.org/downloads/}{\texttt{ python.\+org}}.
\item Ubiquese en la siguiente direccion\+: /\+TAREA\+\_\+\+CUATRO
\item Ejecute el siguiente comando para entrar al menu del programa\+: make
\end{DoxyEnumerate}\hypertarget{index_autotoc_md1}{}\doxysection{Análisis de Rendimiento}\label{index_autotoc_md1}
En el análisis de rendimiento realizado en el programa, se identificaron las funciones que consumen más tiempo y recursos de entre todas las funciones y clases. A continuación, se detallan las funciones identificadas\+:


\begin{DoxyEnumerate}
\item {\ttfamily calcular\+\_\+puntuacion\+\_\+general}\+: Esta función es la que consume más tiempo en el cálculo de la Evaluación General basada en Tipos de Alergias Ingresadas. Sin embargo, el tiempo que consume es muy bajo, en el rango de microsegundos.
\item {\ttfamily built-\/in method builtins.\+sum}\+: Esta función se utiliza para calcular la puntuación total combinada de las alergias. También consume muy poco tiempo.
\end{DoxyEnumerate}\hypertarget{index_autotoc_md2}{}\doxysubsection{Aumento de la Cantidad de Puntuación}\label{index_autotoc_md2}
Se ejecutó las opciones {\ttfamily ingresar\+\_\+puntuación\+\_\+general}, {\ttfamily Agregar nueva alergia al sistema}y {\ttfamily Mostrar ambas evaluaciones} (Estas utilizan todas las funciones del programa y se puede medir el rendimiento general) con diferentes valores de puntuación, aumentando la cantidad. Los resultados obtenidos fueron los siguientes\+:


\begin{DoxyItemize}
\item Cuando se ingresó una puntuación de 10, se obtuvo un tiempo para evaluar alergias de \+: 3.\+9000042306724936e-\/07 segundos
\item Cuando se ingresó una puntuación de 100000000000000000000000000000000000000000000000000, se obtuvo un tiempo para evaluar alergias de \+: 3.\+899986040778458e-\/07 segundos
\item Cuando se agrego una nueva alergia con un puntuaje de 14 se obtuvo un tiempo para agregar alergia de\+: 8.\+457000149064697e-\/06 segundos
\item Cuando se agrego una nueva alergia con un puntuaje de 232323232323232323232323232323232323 se obtuvo un tiempo para agregar alergia de\+: 9.\+890000001178123e-\/06 segundos
\end{DoxyItemize}\hypertarget{index_autotoc_md3}{}\doxysubsubsection{Conclusiones}\label{index_autotoc_md3}
Según el análisis de rendimiento, se observa que el tiempo de ejecución de la función {\ttfamily ingresar\+\_\+puntuacion\+\_\+general} se mantiene en un rango muy bajo y constante, independientemente del aumento en la cantidad de puntuación ingresada. Esto indica que las funciones son altamente eficientes y no presentan un aumento significativo en el tiempo de ejecución a medida que se procesan puntuaciones más grandes.\hypertarget{index_autotoc_md4}{}\doxysection{Parte Teorica}\label{index_autotoc_md4}

\begin{DoxyEnumerate}
\item {\bfseries{Diferencia entre una lista y una tupla en Python\+:}}
\begin{DoxyItemize}
\item Una lista es una colección ordenada y mutable de elementos en Python, lo que significa que se pueden agregar, eliminar o modificar elementos después de su creación utilizando índices.
\item Una tupla es similar a una lista en cuanto a que es una colección ordenada de elementos, pero a diferencia de las listas, las tuplas son inmutables, lo que significa que no se pueden modificar después de su creación.
\end{DoxyItemize}
\item {\bfseries{Sobrecarga de operadores en Python\+:}}
\begin{DoxyItemize}
\item La sobrecarga de operadores se refiere a la capacidad de definir comportamientos personalizados para operadores en clases definidas por el usuario.
\item Se implementa en Python mediante la definición de métodos especiales en una clase, como {\ttfamily \+\_\+\+\_\+add\+\_\+\+\_\+} para la adición, {\ttfamily \+\_\+\+\_\+sub\+\_\+\+\_\+} para la resta, etc. Estos métodos permiten definir cómo se deben comportar los operadores cuando se aplican a objetos de esa clase.
\end{DoxyItemize}
\item {\bfseries{Alcance (scope) de una variable en Python\+:}}
\begin{DoxyItemize}
\item El alcance se refiere a la región del programa en la que una variable es visible y puede ser referenciada.
\item En Python, el alcance de una variable se determina por las reglas de ámbito local y global. Las variables definidas dentro de una función tienen un ámbito local y no son visibles fuera de esa función, mientras que las variables definidas fuera de todas las funciones tienen un ámbito global y son visibles en todo el programa.
\end{DoxyItemize}
\item {\bfseries{Decorador en Python\+:}}
\begin{DoxyItemize}
\item Un decorador en Python es una función que se utiliza para modificar o extender el comportamiento de otra función o método sin cambiar su código fuente.
\item La función principal de un decorador es envolver una función existente y agregar funcionalidad adicional antes o después de la ejecución de la función original.
\end{DoxyItemize}
\item {\bfseries{Gestión de excepciones en Python\+:}}
\begin{DoxyItemize}
\item Las excepciones se gestionan mediante bloques {\ttfamily try}, {\ttfamily except} y opcionalmente {\ttfamily finally}.
\item Ejemplo\+: \`{}\`{}\`{}python try\+: \begin{DoxyVerb}resultado = 10 / 0
\end{DoxyVerb}
 except Zero\+Division\+Error as e\+: print(f\char`\"{}\+Error\+: \{e\}\char`\"{}) finally\+: print(\char`\"{}\+Este bloque se ejecuta siempre\char`\"{}) \`{}\`{}\`{}
\end{DoxyItemize}
\item {\bfseries{Generadores en Python\+:}}
\begin{DoxyItemize}
\item Un generador es una función especial que permite crear secuencias de valores de manera eficiente.
\item Se utilizan para generar valores bajo demanda en lugar de almacenar todos los valores en la memoria.
\item Se definen con una función que contiene la palabra clave {\ttfamily yield}.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre {\ttfamily \+\_\+\+\_\+init\+\_\+\+\_\+} y {\ttfamily \+\_\+\+\_\+call\+\_\+\+\_\+} en clases de Python\+:}}
\begin{DoxyItemize}
\item {\ttfamily \+\_\+\+\_\+init\+\_\+\+\_\+} es un método especial llamado cuando se crea una instancia de una clase. Se utiliza para inicializar los atributos de la instancia.
\item {\ttfamily \+\_\+\+\_\+call\+\_\+\+\_\+} es un método especial que permite que una instancia de una clase se comporte como una función cuando se llama. Puede aceptar argumentos y realizar acciones adicionales.
\end{DoxyItemize}
\item {\bfseries{Organización de módulos y paquetes en Python\+:}}
\begin{DoxyItemize}
\item Los módulos son archivos de Python que contienen código reutilizable.
\item Los paquetes son carpetas que contienen módulos relacionados. Deben incluir un archivo {\ttfamily \+\_\+\+\_\+init\+\_\+\+\_\+.\+py} para que Python los reconozca como paquetes.
\item Los paquetes pueden contener subpaquetes y módulos anidados.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre {\ttfamily append()} y {\ttfamily extend()} en listas de Python\+:}}
\begin{DoxyItemize}
\item {\ttfamily append()} se utiliza para agregar un elemento al final de una lista.
\item {\ttfamily extend()} se utiliza para agregar los elementos de una iterable (como una lista o tupla) al final de una lista existente.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre método de clase y método estático en Python\+:}}
\begin{DoxyItemize}
\item Un método de clase se asocia a la clase y puede acceder y modificar atributos de clase. Se define con el decorador {\ttfamily @classmethod}.
\item Un método estático no se asocia a la instancia o la clase y generalmente se utiliza para funcionalidad relacionada con la clase que no necesita acceder a atributos específicos de la instancia o la clase. Se define con el decorador {\ttfamily @staticmethod}.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre herencia simple y herencia múltiple en Python\+:}}
\begin{DoxyItemize}
\item La herencia simple permite que una clase herede de una única clase base.
\item La herencia múltiple permite que una clase herede de múltiples clases base. Python admite herencia múltiple, lo que significa que una clase puede heredar atributos y métodos de varias clases base.
\end{DoxyItemize}
\item {\bfseries{Manejo de errores de importación de módulos en Python\+:}}
\begin{DoxyItemize}
\item Python generará una excepción {\ttfamily Module\+Not\+Found\+Error} si intenta importar un módulo que no existe.
\item Puede manejar esta excepción utilizando un bloque {\ttfamily try} y {\ttfamily except} para proporcionar un mensaje de error personalizado o tomar acciones específicas en caso de que el módulo no se pueda importar.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre una clase y un objeto en Python\+:}}
\begin{DoxyItemize}
\item Una clase es una plantilla o un plano para crear objetos. Define atributos y métodos que los objetos de esa clase tendrán.
\item Un objeto es una instancia concreta de una clase. Es una entidad que tiene atributos específicos y puede realizar acciones definidas en la clase.
\end{DoxyItemize}
\item {\bfseries{Diferencia entre una clase abstracta y una interfaz en Python\+:}}
\begin{DoxyItemize}
\item Una clase abstracta es una clase que no se puede instanciar directamente y generalmente contiene métodos abstractos que deben ser implementados por las clases derivadas.
\item Una interfaz en Python se define utilizando clases abstractas y se utiliza para definir un conjunto de métodos que deben ser implementados por cualquier clase que la herede.
\end{DoxyItemize}
\item {\bfseries{Sobreescritura de métodos en Python\+:}}
\begin{DoxyItemize}
\item La sobreescritura de métodos se refiere a la capacidad de una clase derivada para proporcionar su propia implementación de un método que ya está definido en la clase base.
\item Se realiza definiendo un método con el mismo nombre en la clase derivada, lo que anulará el comportamiento del método en la clase base. 
\end{DoxyItemize}
\end{DoxyEnumerate}